<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand-Tracking Fish Catching Game</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            overflow: hidden;
            background: linear-gradient(180deg, #001a33 0%, #003d66 50%, #004d73 100%);
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #videoContainer {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 240px;
            height: 180px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        #videoElement {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #cameraCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }

        .hud {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 20px 30px;
            background: rgba(0, 30, 60, 0.6);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            color: white;
            z-index: 100;
        }

        .hud-title {
            font-size: 14px;
            opacity: 0.7;
            margin-bottom: 8px;
        }

        .hud-value {
            font-size: 48px;
            font-weight: 700;
            color: #00d4ff;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        .audio-controls {
            position: fixed;
            top: 120px;
            left: 20px;
            padding: 15px 20px;
            background: rgba(0, 30, 60, 0.6);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            color: white;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .audio-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 10px 15px;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .audio-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
            transform: scale(1.05);
        }

        .volume-control {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .volume-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            cursor: pointer;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00d4ff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        .volume-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00d4ff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
            border: none;
        }

        .volume-value {
            font-size: 12px;
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
        }

        .difficulty-container {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 12px;
            z-index: 100;
        }

        .difficulty-btn {
            padding: 12px 24px;
            background: rgba(0, 30, 60, 0.6);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .difficulty-btn:hover {
            background: rgba(0, 50, 100, 0.8);
            border-color: rgba(255, 255, 255, 0.4);
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(0, 212, 255, 0.3);
        }

        .difficulty-btn.active {
            background: rgba(0, 212, 255, 0.3);
            border-color: #00d4ff;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
            z-index: 200;
        }

        .loading-text {
            margin-top: 20px;
            opacity: 0.8;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top-color: #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .score-popup {
            position: fixed;
            font-size: 36px;
            font-weight: 700;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            pointer-events: none;
            z-index: 150;
            animation: scoreFloat 1s ease-out forwards;
        }

        @keyframes scoreFloat {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-80px) scale(1.5);
            }
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div class="spinner"></div>
        <div class="loading-text">Initializing camera...</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="videoContainer">
        <video id="videoElement" autoplay playsinline></video>
        <canvas id="cameraCanvas"></canvas>
    </div>

    <div class="hud">
        <div class="hud-title">Fish Caught</div>
        <div class="hud-value" id="score">0</div>
    </div>

    <div class="audio-controls">
        <button id="muteBtn" class="audio-btn">ðŸ”Š</button>
        <div class="volume-control">
            <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.3" class="volume-slider">
            <span id="volumeValue" class="volume-value">30%</span>
        </div>
    </div>

    <div class="difficulty-container">
        <button class="difficulty-btn active" data-difficulty="beginner">Beginner</button>
        <button class="difficulty-btn" data-difficulty="intermediate">Intermediate</button>
        <button class="difficulty-btn" data-difficulty="advanced">Advanced</button>
    </div>

    <script>
        // Perlin Noise Implementation
        class PerlinNoise {
            constructor() {
                this.permutation = [];
                for (let i = 0; i < 256; i++) this.permutation[i] = i;
                for (let i = 255; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.permutation[i], this.permutation[j]] = [this.permutation[j], this.permutation[i]];
                }
                this.p = [...this.permutation, ...this.permutation];
            }

            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }

            lerp(t, a, b) {
                return a + t * (b - a);
            }

            grad(hash, x, y) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }

            noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = this.fade(x);
                const v = this.fade(y);
                const a = this.p[X] + Y;
                const b = this.p[X + 1] + Y;
                return this.lerp(v,
                    this.lerp(u, this.grad(this.p[a], x, y), this.grad(this.p[b], x - 1, y)),
                    this.lerp(u, this.grad(this.p[a + 1], x, y - 1), this.grad(this.p[b + 1], x - 1, y - 1))
                );
            }
        }

        // Audio Manager - Web Audio API synthesis for underwater sounds
        class AudioManager {
            constructor() {
                this.context = null;
                this.masterGain = null;
                this.ambienceGain = null;
                this.sfxGain = null;
                this.isMuted = false;
                this.volume = 0.3; // 30% default

                // MP3 ambience
                this.mp3Audio = null;
                this.mp3Source = null;
                this.mp3Gain = null;
                this.useMp3 = false;

                // Synthesized ambience nodes (fallback)
                this.noiseNode = null;
                this.noiseGain = null;
                this.lowpassFilter = null;
                this.lfoGain = null;
                this.lfo = null;
                this.bubbleInterval = null;
            }

            async init() {
                try {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();

                    // Master gain control
                    this.masterGain = this.context.createGain();
                    this.masterGain.gain.value = this.volume;
                    this.masterGain.connect(this.context.destination);

                    // Ambience gain
                    this.ambienceGain = this.context.createGain();
                    this.ambienceGain.gain.value = 0.25; // 25% for ambience
                    this.ambienceGain.connect(this.masterGain);

                    // SFX gain
                    this.sfxGain = this.context.createGain();
                    this.sfxGain.gain.value = 0.5; // 50% for SFX
                    this.sfxGain.connect(this.masterGain);

                    console.log('AudioManager initialized');
                } catch (error) {
                    console.error('Audio initialization failed:', error);
                }
            }

            async resume() {
                if (this.context && this.context.state === 'suspended') {
                    await this.context.resume();
                }
            }

            createNoiseBuffer() {
                const bufferSize = this.context.sampleRate * 2; // 2 seconds of noise
                const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
                const data = buffer.getChannelData(0);

                // Generate pink noise (more natural than white noise)
                let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    b0 = 0.99886 * b0 + white * 0.0555179;
                    b1 = 0.99332 * b1 + white * 0.0750759;
                    b2 = 0.96900 * b2 + white * 0.1538520;
                    b3 = 0.86650 * b3 + white * 0.3104856;
                    b4 = 0.55000 * b4 + white * 0.5329522;
                    b5 = -0.7616 * b5 - white * 0.0168980;
                    data[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
                    b6 = white * 0.115926;
                }

                return buffer;
            }

            async startAmbience() {
                if (!this.context) return;

                this.stopAmbience(); // Clean up any existing ambience

                // Try to load MP3 file first
                try {
                    await this.loadMp3Ambience();
                    console.log('Using MP3 underwater ambience');
                    return;
                } catch (error) {
                    console.log('MP3 not found, using synthesized ambience');
                }

                // Fallback to synthesized ambience
                // Create noise source
                const noiseBuffer = this.createNoiseBuffer();
                this.noiseNode = this.context.createBufferSource();
                this.noiseNode.buffer = noiseBuffer;
                this.noiseNode.loop = true;

                // Noise gain for mixing
                this.noiseGain = this.context.createGain();
                this.noiseGain.gain.value = 0.4;

                // Lowpass filter for underwater muffled effect
                this.lowpassFilter = this.context.createBiquadFilter();
                this.lowpassFilter.type = 'lowpass';
                this.lowpassFilter.frequency.value = 300; // Very low for deep underwater
                this.lowpassFilter.Q.value = 1;

                // LFO for subtle pressure variation
                this.lfo = this.context.createOscillator();
                this.lfo.frequency.value = 0.1; // 0.1 Hz - very slow
                this.lfoGain = this.context.createGain();
                this.lfoGain.gain.value = 50; // Modulation depth

                // Connect LFO to filter frequency for subtle movement
                this.lfo.connect(this.lfoGain);
                this.lfoGain.connect(this.lowpassFilter.frequency);

                // Connect audio chain
                this.noiseNode.connect(this.noiseGain);
                this.noiseGain.connect(this.lowpassFilter);
                this.lowpassFilter.connect(this.ambienceGain);

                // Start nodes
                this.noiseNode.start(0);
                this.lfo.start(0);

                // Add random bubble pops
                this.startBubblePops();
            }

            async loadMp3Ambience() {
                return new Promise((resolve, reject) => {
                    console.log('Attempting to load MP3 file...');

                    // Create audio element
                    this.mp3Audio = new Audio();
                    this.mp3Audio.src = 'æµ·åº•æ°´æµæ¶ŒåŠ¨éŸ³æ•ˆ.mp3';
                    this.mp3Audio.loop = true;
                    this.mp3Audio.crossOrigin = 'anonymous';
                    this.mp3Audio.volume = 1.0; // Set to max, control via gain node
                    console.log('Audio element created with src:', this.mp3Audio.src);

                    // Create media source node BEFORE loading
                    try {
                        this.mp3Source = this.context.createMediaElementSource(this.mp3Audio);
                        this.mp3Gain = this.context.createGain();
                        this.mp3Gain.gain.value = 0.6; // MP3 volume level

                        // Connect to audio chain
                        this.mp3Source.connect(this.mp3Gain);
                        this.mp3Gain.connect(this.ambienceGain);
                        console.log('Audio chain connected');
                    } catch (error) {
                        console.error('Error creating media source:', error);
                        reject(error);
                        return;
                    }

                    // Handle load success
                    this.mp3Audio.addEventListener('canplaythrough', () => {
                        console.log('MP3 file loaded successfully');
                        // Play the audio
                        this.mp3Audio.play().then(() => {
                            console.log('MP3 playback started');
                            this.useMp3 = true;
                            resolve();
                        }).catch(error => {
                            console.error('Playback error:', error);
                            reject(error);
                        });
                    }, { once: true });

                    // Handle load error
                    this.mp3Audio.addEventListener('error', (e) => {
                        console.error('MP3 load error:', e);
                        reject(new Error('MP3 file not found or failed to load'));
                    }, { once: true });

                    // Start loading
                    this.mp3Audio.load();
                });
            }

            startBubblePops() {
                // Random bubble sounds every 2-5 seconds
                const scheduleBubble = () => {
                    const delay = 2000 + Math.random() * 3000;
                    this.bubbleInterval = setTimeout(() => {
                        this.playBubblePop();
                        scheduleBubble();
                    }, delay);
                };
                scheduleBubble();
            }

            playBubblePop() {
                if (!this.context) return;

                const now = this.context.currentTime;

                // Create oscillator for bubble sound
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();

                // Bubble pitch (high frequency, quick decay)
                osc.frequency.setValueAtTime(800 + Math.random() * 400, now);
                osc.frequency.exponentialRampToValueAtTime(200, now + 0.1);

                // Bubble envelope (quick pop)
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.02, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);

                osc.connect(gain);
                gain.connect(this.ambienceGain);

                osc.start(now);
                osc.stop(now + 0.15);
            }

            stopAmbience() {
                // Stop MP3 if playing
                if (this.mp3Audio) {
                    this.mp3Audio.pause();
                    this.mp3Audio = null;
                }
                if (this.mp3Source) {
                    this.mp3Source.disconnect();
                    this.mp3Source = null;
                }
                if (this.mp3Gain) {
                    this.mp3Gain.disconnect();
                    this.mp3Gain = null;
                }
                this.useMp3 = false;

                // Stop synthesized ambience
                if (this.noiseNode) {
                    this.noiseNode.stop();
                    this.noiseNode.disconnect();
                    this.noiseNode = null;
                }
                if (this.lfo) {
                    this.lfo.stop();
                    this.lfo.disconnect();
                    this.lfo = null;
                }
                if (this.noiseGain) {
                    this.noiseGain.disconnect();
                    this.noiseGain = null;
                }
                if (this.lowpassFilter) {
                    this.lowpassFilter.disconnect();
                    this.lowpassFilter = null;
                }
                if (this.lfoGain) {
                    this.lfoGain.disconnect();
                    this.lfoGain = null;
                }
                if (this.bubbleInterval) {
                    clearTimeout(this.bubbleInterval);
                    this.bubbleInterval = null;
                }
            }

            playCatchSfx() {
                if (!this.context) return;

                const now = this.context.currentTime;

                // Create oscillator for catch sound
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();

                // Pleasant "ding/pop" sound
                osc.type = 'sine';
                osc.frequency.setValueAtTime(880, now); // A5 note
                osc.frequency.exponentialRampToValueAtTime(440, now + 0.1); // Drop to A4

                // Quick attack, medium decay
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.3, now + 0.01); // Quick attack
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15); // Medium decay

                osc.connect(gain);
                gain.connect(this.sfxGain);

                osc.start(now);
                osc.stop(now + 0.15);
            }

            setMasterVolume(value) {
                this.volume = value;
                if (this.masterGain) {
                    this.masterGain.gain.value = this.isMuted ? 0 : value;
                }
                // Also update MP3 volume if using MP3
                if (this.mp3Audio) {
                    this.mp3Audio.volume = this.isMuted ? 0 : value;
                    console.log('MP3 volume set to:', this.mp3Audio.volume);
                }
            }

            toggleMute() {
                this.isMuted = !this.isMuted;
                if (this.masterGain) {
                    this.masterGain.gain.value = this.isMuted ? 0 : this.volume;
                }
                // Also mute/unmute MP3 if using MP3
                if (this.mp3Audio) {
                    this.mp3Audio.volume = this.isMuted ? 0 : this.volume;
                }
                return this.isMuted;
            }
        }

        // Difficulty Settings
        const DIFFICULTY_SETTINGS = {
            beginner: {
                sensitivity: 0.3,  // Reduced from 0.4 - fish less sensitive
                escapeSpeed: 3,    // Reduced from 5 - fish flee slower
                alertRadius: 200,
                slowSpeedThreshold: 16  // Increased from 14 - higher threshold for "slow"
            },
            intermediate: {
                sensitivity: 0.6,  // Reduced from 0.7
                escapeSpeed: 6,    // Reduced from 8
                alertRadius: 280,
                slowSpeedThreshold: 13  // Increased from 12.5
            },
            advanced: {
                sensitivity: 1.0,  // Reduced from 1.2
                escapeSpeed: 9,    // Reduced from 12
                alertRadius: 380,
                slowSpeedThreshold: 11
            }
        };

        // Game State
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.videoElement = document.getElementById('videoElement');
                this.cameraCanvas = document.getElementById('cameraCanvas');
                this.cameraCtx = this.cameraCanvas.getContext('2d');

                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                this.perlin = new PerlinNoise();
                this.fish = [];
                this.shrimp = [];
                this.jellyfish = [];
                this.bubbles = [];
                this.seaweed = [];
                this.time = 0;
                this.score = 0;
                this.difficulty = 'beginner';

                // Hand tracking
                this.handPosition = null;
                this.previousHandPosition = null;
                this.handSpeed = 0;
                this.isFist = false;
                this.wasFist = false;

                // Audio
                this.audioManager = new AudioManager();

                this.setupDifficultyButtons();
                this.setupAudioControls();
                this.initEnvironment();
                this.initFish();
                this.initAudio();
                this.initMediaPipe();
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            setupDifficultyButtons() {
                document.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.difficulty = btn.dataset.difficulty;
                    });
                });
            }

            setupAudioControls() {
                const muteBtn = document.getElementById('muteBtn');
                const volumeSlider = document.getElementById('volumeSlider');
                const volumeValue = document.getElementById('volumeValue');

                muteBtn.addEventListener('click', () => {
                    const isMuted = this.audioManager.toggleMute();
                    muteBtn.textContent = isMuted ? 'ðŸ”‡' : 'ðŸ”Š';
                });

                volumeSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    this.audioManager.setMasterVolume(value);
                    volumeValue.textContent = Math.round(value * 100) + '%';
                });

                // Set initial volume display
                volumeValue.textContent = '30%';
            }

            async initAudio() {
                await this.audioManager.init();
                await this.audioManager.resume();
                await this.audioManager.startAmbience();
            }

            initEnvironment() {
                // Create seaweed
                for (let i = 0; i < 15; i++) {
                    this.seaweed.push({
                        x: Math.random() * this.canvas.width,
                        height: 80 + Math.random() * 120,
                        segments: 8,
                        phase: Math.random() * Math.PI * 2,
                        speed: 0.5 + Math.random() * 0.5
                    });
                }

                // Create bubbles
                for (let i = 0; i < 30; i++) {
                    this.addBubble();
                }

                // Create light particles
                this.particles = [];
                for (let i = 0; i < 60; i++) {
                    this.addParticle();
                }
            }

            addBubble() {
                this.bubbles.push({
                    x: Math.random() * this.canvas.width,
                    y: this.canvas.height + Math.random() * 100,
                    radius: 2 + Math.random() * 4,
                    speed: 0.5 + Math.random() * 1.5,
                    wobble: Math.random() * Math.PI * 2
                });
            }

            addParticle() {
                this.particles.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    size: 1 + Math.random() * 3,
                    speedX: (Math.random() - 0.5) * 0.3,
                    speedY: (Math.random() - 0.5) * 0.3,
                    brightness: 0.3 + Math.random() * 0.7,
                    pulsePhase: Math.random() * Math.PI * 2,
                    pulseSpeed: 0.02 + Math.random() * 0.03,
                    color: ['cyan', 'gold', 'white', 'lightblue'][Math.floor(Math.random() * 4)]
                });
            }

            initFish() {
                // 25 fish (main creatures)
                for (let i = 0; i < 25; i++) {
                    this.fish.push(new Fish(
                        Math.random() * this.canvas.width,
                        Math.random() * this.canvas.height,
                        this.perlin,
                        i
                    ));
                }

                // 8 shrimp (quick burst movers)
                for (let i = 0; i < 8; i++) {
                    this.shrimp.push(new Shrimp(
                        Math.random() * this.canvas.width,
                        Math.random() * this.canvas.height,
                        i
                    ));
                }

                // 5 jellyfish (slow drifters)
                for (let i = 0; i < 5; i++) {
                    this.jellyfish.push(new Jellyfish(
                        Math.random() * this.canvas.width,
                        Math.random() * this.canvas.height,
                        i
                    ));
                }
            }

            async initMediaPipe() {
                const hands = new Hands({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
                });

                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.7,
                    minTrackingConfidence: 0.7
                });

                hands.onResults((results) => this.onHandsResults(results));

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    this.videoElement.srcObject = stream;

                    const camera = new Camera(this.videoElement, {
                        onFrame: async () => {
                            await hands.send({ image: this.videoElement });
                        },
                        width: 640,
                        height: 480
                    });
                    camera.start();

                    document.getElementById('loading').style.display = 'none';
                    this.animate();
                } catch (error) {
                    console.error('Camera error:', error);
                    document.getElementById('loading').innerHTML = '<div class="loading-text">Camera access denied. Please enable camera.</div>';
                }
            }

            onHandsResults(results) {
                // Draw hand skeleton on camera canvas
                this.cameraCanvas.width = this.videoElement.videoWidth;
                this.cameraCanvas.height = this.videoElement.videoHeight;
                this.cameraCtx.clearRect(0, 0, this.cameraCanvas.width, this.cameraCanvas.height);

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];

                    // Draw hand skeleton
                    this.drawHandSkeleton(landmarks);

                    // Get palm center (landmark 9 is palm base)
                    const palm = landmarks[9];
                    const newHandPosition = {
                        x: (1 - palm.x) * this.canvas.width, // Mirror x
                        y: palm.y * this.canvas.height
                    };

                    // Calculate hand speed
                    if (this.previousHandPosition) {
                        const dx = newHandPosition.x - this.previousHandPosition.x;
                        const dy = newHandPosition.y - this.previousHandPosition.y;
                        this.handSpeed = Math.sqrt(dx * dx + dy * dy);
                    }

                    this.previousHandPosition = this.handPosition;
                    this.handPosition = newHandPosition;

                    // Detect fist gesture
                    this.wasFist = this.isFist;
                    this.isFist = this.detectFist(landmarks);
                } else {
                    this.handPosition = null;
                    this.previousHandPosition = null;
                    this.handSpeed = 0;
                    this.wasFist = this.isFist;
                    this.isFist = false;
                }
            }

            drawHandSkeleton(landmarks) {
                const ctx = this.cameraCtx;
                const connections = [
                    [0, 1], [1, 2], [2, 3], [3, 4], // Thumb
                    [0, 5], [5, 6], [6, 7], [7, 8], // Index
                    [0, 9], [9, 10], [10, 11], [11, 12], // Middle
                    [0, 13], [13, 14], [14, 15], [15, 16], // Ring
                    [0, 17], [17, 18], [18, 19], [19, 20], // Pinky
                    [5, 9], [9, 13], [13, 17] // Palm
                ];

                // Draw connections
                ctx.strokeStyle = 'rgba(0, 255, 200, 0.6)';
                ctx.lineWidth = 2;
                connections.forEach(([start, end]) => {
                    ctx.beginPath();
                    ctx.moveTo(landmarks[start].x * this.cameraCanvas.width, landmarks[start].y * this.cameraCanvas.height);
                    ctx.lineTo(landmarks[end].x * this.cameraCanvas.width, landmarks[end].y * this.cameraCanvas.height);
                    ctx.stroke();
                });

                // Draw landmarks
                landmarks.forEach(landmark => {
                    ctx.beginPath();
                    ctx.arc(landmark.x * this.cameraCanvas.width, landmark.y * this.cameraCanvas.height, 3, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(0, 255, 200, 0.8)';
                    ctx.fill();
                });
            }

            detectFist(landmarks) {
                // Check if fingertips are close to palm (more lenient detection)
                const palm = landmarks[0];
                const fingertips = [4, 8, 12, 16, 20];
                let closedCount = 0;

                fingertips.forEach(tip => {
                    const dx = landmarks[tip].x - palm.x;
                    const dy = landmarks[tip].y - palm.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    // Increased threshold from 0.15 to 0.2 for easier detection
                    if (distance < 0.2) closedCount++;
                });

                // Reduced from 4 to 3 fingers for easier detection
                return closedCount >= 3;
            }

            checkCatch() {
                // Only catch on fist transition (open -> fist)
                if (this.isFist && !this.wasFist && this.handPosition) {
                    const settings = DIFFICULTY_SETTINGS[this.difficulty];

                    // Further reduced catch radius for maximum challenge
                    const catchRadius = 80 + (this.handSpeed * 1.5);

                    // Check all creatures
                    const allCreatures = [...this.fish, ...this.shrimp, ...this.jellyfish];

                    allCreatures.forEach(creature => {
                        const dx = creature.x - this.handPosition.x;
                        const dy = creature.y - this.handPosition.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < catchRadius && !creature.isCaught) {
                            creature.catch();
                            this.score++;
                            document.getElementById('score').textContent = this.score;
                            this.showScorePopup(creature.x, creature.y);
                            // Play catch sound effect
                            this.audioManager.playCatchSfx();
                        }
                    });
                }
            }

            showScorePopup(x, y) {
                const popup = document.createElement('div');
                popup.className = 'score-popup';
                popup.textContent = '+1';
                popup.style.left = x + 'px';
                popup.style.top = y + 'px';
                document.body.appendChild(popup);
                setTimeout(() => popup.remove(), 1000);
            }

            update() {
                this.time += 0.016;

                // Update bubbles
                this.bubbles.forEach((bubble, index) => {
                    bubble.y -= bubble.speed;
                    bubble.wobble += 0.02;
                    bubble.x += Math.sin(bubble.wobble) * 0.5;

                    if (bubble.y < -10) {
                        this.bubbles.splice(index, 1);
                        this.addBubble();
                    }
                });

                // Update particles
                this.particles.forEach((particle, index) => {
                    particle.x += particle.speedX;
                    particle.y += particle.speedY;
                    particle.pulsePhase += particle.pulseSpeed;

                    // Wrap around screen
                    if (particle.x < 0) particle.x = this.canvas.width;
                    if (particle.x > this.canvas.width) particle.x = 0;
                    if (particle.y < 0) particle.y = this.canvas.height;
                    if (particle.y > this.canvas.height) particle.y = 0;
                });

                // Update fish
                const settings = DIFFICULTY_SETTINGS[this.difficulty];
                this.fish.forEach(fish => {
                    fish.update(this.fish, this.handPosition, this.handSpeed, settings, this.canvas);
                });

                // Update shrimp (burst movement)
                this.shrimp.forEach(shrimp => {
                    shrimp.update(this.handPosition, this.handSpeed, this.canvas);
                });

                // Update jellyfish (vertical drift)
                this.jellyfish.forEach(jellyfish => {
                    jellyfish.update(this.handPosition, this.handSpeed, this.canvas);
                });

                // Check for catches
                this.checkCatch();
            }

            draw() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw gradient background
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#001a33');
                gradient.addColorStop(0.5, '#003d66');
                gradient.addColorStop(1, '#004d73');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw light shafts
                this.drawLightShafts();

                // Draw seaweed
                this.drawSeaweed();

                // Draw bubbles
                this.drawBubbles();

                // Draw particles
                this.drawParticles();

                // Draw jellyfish (background layer - slow drifters)
                this.jellyfish.forEach(jellyfish => jellyfish.draw(this.ctx));

                // Draw fish (middle layer - main creatures)
                this.fish.forEach(fish => fish.draw(this.ctx));

                // Draw shrimp (foreground layer - quick movers)
                this.shrimp.forEach(shrimp => shrimp.draw(this.ctx));

                // Draw hand indicator
                if (this.handPosition) {
                    this.drawHandIndicator();
                }
            }

            drawLightShafts() {
                const ctx = this.ctx;
                ctx.save();

                for (let i = 0; i < 5; i++) {
                    const x = (i / 4) * this.canvas.width;
                    const gradient = ctx.createLinearGradient(x, 0, x, this.canvas.height);
                    gradient.addColorStop(0, 'rgba(135, 206, 250, 0.1)');
                    gradient.addColorStop(0.5, 'rgba(135, 206, 250, 0.03)');
                    gradient.addColorStop(1, 'rgba(135, 206, 250, 0)');

                    ctx.fillStyle = gradient;
                    ctx.fillRect(x - 30, 0, 60, this.canvas.height);
                }

                ctx.restore();
            }

            drawSeaweed() {
                const ctx = this.ctx;

                this.seaweed.forEach(weed => {
                    ctx.save();
                    ctx.translate(weed.x, this.canvas.height);

                    ctx.strokeStyle = 'rgba(46, 125, 50, 0.6)';
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';

                    const segmentHeight = weed.height / weed.segments;

                    ctx.beginPath();
                    ctx.moveTo(0, 0);

                    for (let i = 1; i <= weed.segments; i++) {
                        const offset = Math.sin(this.time * weed.speed + weed.phase + i * 0.3) * (i * 2);
                        ctx.lineTo(offset, -i * segmentHeight);
                    }

                    ctx.stroke();
                    ctx.restore();
                });
            }

            drawBubbles() {
                const ctx = this.ctx;

                this.bubbles.forEach(bubble => {
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(135, 206, 250, 0.3)';
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.restore();
                });
            }

            drawParticles() {
                const ctx = this.ctx;

                this.particles.forEach(particle => {
                    ctx.save();

                    // Pulsing brightness effect
                    const pulse = Math.sin(particle.pulsePhase) * 0.3 + 0.7;
                    const alpha = particle.brightness * pulse;

                    // Color based on particle type
                    let color;
                    switch(particle.color) {
                        case 'cyan': color = `rgba(0, 255, 255, ${alpha})`; break;
                        case 'gold': color = `rgba(255, 215, 0, ${alpha})`; break;
                        case 'white': color = `rgba(255, 255, 255, ${alpha})`; break;
                        case 'lightblue': color = `rgba(173, 216, 230, ${alpha})`; break;
                    }

                    // Glow effect
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 10 + (pulse * 5);

                    // Draw particle
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.fill();

                    // Additional glow ring
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size + 2, 0, Math.PI * 2);
                    ctx.strokeStyle = color.replace(alpha, alpha * 0.3);
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    ctx.restore();
                });
            }

            drawHandIndicator() {
                const ctx = this.ctx;
                const pos = this.handPosition;

                // Calculate color based on speed
                const speedRatio = Math.min(this.handSpeed / 20, 1);
                const hue = 180 - (speedRatio * 180); // Cyan (180) to Red (0)

                // Ring size and glow based on speed
                const baseRadius = 40;
                const radius = baseRadius + (speedRatio * 20);
                const strokeWidth = 3 + (speedRatio * 2);
                const glowIntensity = 0.3 + (speedRatio * 0.5);

                ctx.save();

                // Glow effect
                ctx.shadowColor = `hsla(${hue}, 100%, 50%, ${glowIntensity})`;
                ctx.shadowBlur = 20 + (speedRatio * 20);

                // Main ring
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
                ctx.lineWidth = strokeWidth;
                ctx.stroke();

                // Warning ripples for fast movement
                if (speedRatio > 0.6) {
                    for (let i = 0; i < 3; i++) {
                        const rippleRadius = radius + (i * 15) + (this.time * 30 % 45);
                        const rippleOpacity = (1 - (this.time * 30 % 45) / 45) * 0.5;

                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, rippleRadius, 0, Math.PI * 2);
                        ctx.strokeStyle = `rgba(255, 0, 0, ${rippleOpacity})`;
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }

                // Fist grab effect
                if (this.isFist) {
                    // Show catch radius when fist is detected (matches actual catch radius)
                    const catchRadius = 80 + (this.handSpeed * 1.5);

                    // Draw catch area indicator
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, catchRadius, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.15)';
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    const meshRadius = Math.min(radius * 0.6, 50);
                    const meshSegments = 8;

                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
                    ctx.lineWidth = 2;

                    // Radial lines
                    for (let i = 0; i < meshSegments; i++) {
                        const angle = (Math.PI * 2 / meshSegments) * i;
                        const x1 = pos.x + Math.cos(angle) * (meshRadius * 0.3);
                        const y1 = pos.y + Math.sin(angle) * (meshRadius * 0.3);
                        const x2 = pos.x + Math.cos(angle) * meshRadius;
                        const y2 = pos.y + Math.sin(angle) * meshRadius;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }

                    // Concentric circles
                    for (let i = 1; i <= 3; i++) {
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, (meshRadius / 3) * i, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }

                ctx.restore();
            }

            animate() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
        }

        // Fish Types
        const FISH_TYPES = [
            {
                name: 'Cyan Tang',
                colors: ['#4dd0e1', '#26c6da', '#00acc1'],
                glowColor: [0, 200, 255],
                sizeMultiplier: 1.0
            },
            {
                name: 'Golden Butterfly',
                colors: ['#ffd700', '#ffb300', '#ff8f00'],
                glowColor: [255, 215, 0],
                sizeMultiplier: 0.8
            },
            {
                name: 'Violet Damsel',
                colors: ['#ba68c8', '#9c27b0', '#7b1fa2'],
                glowColor: [186, 104, 200],
                sizeMultiplier: 0.7
            },
            {
                name: 'Emerald Wrasse',
                colors: ['#66bb6a', '#43a047', '#2e7d32'],
                glowColor: [102, 187, 106],
                sizeMultiplier: 1.1
            },
            {
                name: 'Coral Goby',
                colors: ['#ff7043', '#f4511e', '#d84315'],
                glowColor: [255, 112, 67],
                sizeMultiplier: 0.6
            },
            {
                name: 'Azure Chromis',
                colors: ['#42a5f5', '#1e88e5', '#1565c0'],
                glowColor: [66, 165, 245],
                sizeMultiplier: 0.9
            }
        ];

        // Shrimp Class - Quick burst movements
        class Shrimp {
            constructor(x, y, id) {
                this.x = x;
                this.y = y;
                this.id = id;
                this.type = 'shrimp';

                // Movement
                this.vx = 0;
                this.vy = 0;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = 0;

                // Burst behavior
                this.isMoving = false;
                this.pauseDuration = 0.5 + Math.random() * 1.5; // 0.5-2s pause
                this.moveDuration = 0.2 + Math.random() * 0.3; // 0.2-0.5s burst
                this.actionTimer = 0;
                this.burstSpeed = 6 + Math.random() * 4; // Fast bursts

                // Visual
                this.bodyLength = 15 + Math.random() * 10;
                this.glowIntensity = 0.6 + Math.random() * 0.3;
                this.pulsePhase = Math.random() * Math.PI * 2;

                // Catch state
                this.isCaught = false;
                this.catchTime = 0;
            }

            update(handPos, handSpeed, canvas) {
                if (this.isCaught) {
                    this.catchTime += 0.016;
                    if (this.catchTime > 2) this.respawn(canvas);
                    return;
                }

                this.actionTimer += 0.016;
                this.pulsePhase += 0.08;

                // React to hand threat
                if (handPos) {
                    const dx = this.x - handPos.x;
                    const dy = this.y - handPos.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 150 && handSpeed > 10) {
                        // Flee in quick bursts
                        this.angle = Math.atan2(dy, dx);
                        this.isMoving = true;
                        this.actionTimer = 0;
                    }
                }

                // Burst movement pattern
                if (this.isMoving) {
                    if (this.actionTimer < this.moveDuration) {
                        this.speed = this.burstSpeed;
                    } else {
                        this.isMoving = false;
                        this.speed = 0;
                        this.actionTimer = 0;
                        this.pauseDuration = 0.5 + Math.random() * 1.5;
                    }
                } else {
                    if (this.actionTimer > this.pauseDuration) {
                        this.isMoving = true;
                        this.actionTimer = 0;
                        this.angle = Math.random() * Math.PI * 2;
                        this.moveDuration = 0.2 + Math.random() * 0.3;
                    }
                }

                // Apply movement
                this.vx = Math.cos(this.angle) * this.speed;
                this.vy = Math.sin(this.angle) * this.speed;
                this.x += this.vx;
                this.y += this.vy;

                // Boundaries
                this.x = Math.max(20, Math.min(this.x, canvas.width - 20));
                this.y = Math.max(20, Math.min(this.y, canvas.height - 20));
            }

            catch() {
                this.isCaught = true;
                this.catchTime = 0;
            }

            respawn(canvas) {
                this.isCaught = false;
                this.catchTime = 0;
                const edge = Math.floor(Math.random() * 4);
                switch (edge) {
                    case 0: this.x = Math.random() * canvas.width; this.y = -30; break;
                    case 1: this.x = canvas.width + 30; this.y = Math.random() * canvas.height; break;
                    case 2: this.x = Math.random() * canvas.width; this.y = canvas.height + 30; break;
                    case 3: this.x = -30; this.y = Math.random() * canvas.height; break;
                }
            }

            draw(ctx) {
                if (this.isCaught) return;

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Pulsing glow
                const pulse = Math.sin(this.pulsePhase) * 0.2 + 0.8;
                ctx.shadowColor = `rgba(255, 150, 100, ${this.glowIntensity * pulse})`;
                ctx.shadowBlur = 15;

                // Body (pink-orange)
                const gradient = ctx.createLinearGradient(-this.bodyLength/2, 0, this.bodyLength/2, 0);
                gradient.addColorStop(0, '#ff9a76');
                gradient.addColorStop(0.5, '#ff7e5f');
                gradient.addColorStop(1, '#feb47b');

                ctx.beginPath();
                ctx.ellipse(0, 0, this.bodyLength/2, this.bodyLength/4, 0, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();

                // Tail segments
                for (let i = 0; i < 3; i++) {
                    const offset = this.bodyLength/2 + i * 4;
                    ctx.beginPath();
                    ctx.arc(offset, 0, 3 - i, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 126, 95, ${0.8 - i * 0.2})`;
                    ctx.fill();
                }

                // Antennae
                ctx.strokeStyle = 'rgba(255, 200, 150, 0.6)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(-this.bodyLength/2, 0);
                ctx.lineTo(-this.bodyLength/2 - 8, -5);
                ctx.moveTo(-this.bodyLength/2, 0);
                ctx.lineTo(-this.bodyLength/2 - 8, 5);
                ctx.stroke();

                // Eye
                ctx.beginPath();
                ctx.arc(-this.bodyLength/3, 0, 2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fill();

                ctx.restore();
            }
        }

        // Jellyfish Class - Slow vertical drift with pulsing
        class Jellyfish {
            constructor(x, y, id) {
                this.x = x;
                this.y = y;
                this.id = id;
                this.type = 'jellyfish';
                this.jellyfishVariant = Math.floor(Math.random() * 2); // 0 or 1 for variety

                // Movement
                this.vx = (Math.random() - 0.5) * 0.5; // Slow horizontal drift
                this.vy = -0.5 - Math.random() * 0.5; // Slow upward movement
                this.angle = 0;

                // Pulsing
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.pulseSpeed = 0.03 + Math.random() * 0.02;
                this.size = 20 + Math.random() * 15;

                // Visual
                this.glowIntensity = 0.7 + Math.random() * 0.3;
                this.tentacles = [];
                for (let i = 0; i < 6; i++) {
                    this.tentacles.push({
                        offset: (i / 6) * Math.PI * 2,
                        length: this.size * (1.5 + Math.random() * 0.5),
                        wave: Math.random() * Math.PI * 2
                    });
                }

                // Catch state
                this.isCaught = false;
                this.catchTime = 0;
            }

            update(handPos, handSpeed, canvas) {
                if (this.isCaught) {
                    this.catchTime += 0.016;
                    if (this.catchTime > 2) this.respawn(canvas);
                    return;
                }

                this.pulsePhase += this.pulseSpeed;

                // React to hand (gentle avoidance)
                if (handPos) {
                    const dx = this.x - handPos.x;
                    const dy = this.y - handPos.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 200) {
                        const avoidForce = (200 - distance) / 200 * 0.02;
                        this.vx += (dx / distance) * avoidForce;
                        this.vy += (dy / distance) * avoidForce;
                    }
                }

                // Apply movement
                this.x += this.vx;
                this.y += this.vy;

                // Wrap around screen
                if (this.y < -50) this.y = canvas.height + 50;
                if (this.x < -50) this.x = canvas.width + 50;
                if (this.x > canvas.width + 50) this.x = -50;

                // Damping
                this.vx *= 0.99;
                this.vy *= 0.99;

                // Maintain upward drift
                if (this.vy > -0.3) this.vy -= 0.01;

                // Update tentacle waves
                this.tentacles.forEach(t => t.wave += 0.05);
            }

            catch() {
                this.isCaught = true;
                this.catchTime = 0;
            }

            respawn(canvas) {
                this.isCaught = false;
                this.catchTime = 0;
                this.x = Math.random() * canvas.width;
                this.y = canvas.height + 50;
            }

            draw(ctx) {
                if (this.isCaught) return;

                ctx.save();
                ctx.translate(this.x, this.y);

                // Pulsing animation
                const pulse = Math.sin(this.pulsePhase) * 0.2 + 0.8;
                const currentSize = this.size * pulse;

                // Color variations
                const colors = this.jellyfishVariant === 0
                    ? ['rgba(180, 130, 255, 0.6)', 'rgba(150, 100, 255, 0.4)', 'rgba(120, 80, 200, 0.25)']
                    : ['rgba(100, 200, 255, 0.6)', 'rgba(80, 180, 255, 0.4)', 'rgba(60, 150, 220, 0.25)'];

                // Glow effect
                ctx.shadowColor = this.jellyfishVariant === 0 ? `rgba(150, 100, 255, ${this.glowIntensity * pulse})` : `rgba(100, 200, 255, ${this.glowIntensity * pulse})`;
                ctx.shadowBlur = 30;

                // Bell (main dome) - with realistic shape
                ctx.beginPath();
                ctx.moveTo(0, -currentSize * 0.1);

                // Top of bell (rounded dome)
                ctx.bezierCurveTo(
                    -currentSize * 0.5, -currentSize * 0.1,
                    -currentSize * 0.8, currentSize * 0.3,
                    -currentSize * 0.7, currentSize * 0.8
                );

                // Bottom left curve
                ctx.quadraticCurveTo(
                    -currentSize * 0.4, currentSize * 0.9,
                    0, currentSize
                );

                // Bottom right curve
                ctx.quadraticCurveTo(
                    currentSize * 0.4, currentSize * 0.9,
                    currentSize * 0.7, currentSize * 0.8
                );

                // Right side
                ctx.bezierCurveTo(
                    currentSize * 0.8, currentSize * 0.3,
                    currentSize * 0.5, -currentSize * 0.1,
                    0, -currentSize * 0.1
                );

                // Bell gradient
                const bellGrad = ctx.createRadialGradient(0, currentSize * 0.2, 0, 0, currentSize * 0.2, currentSize);
                bellGrad.addColorStop(0, colors[0]);
                bellGrad.addColorStop(0.6, colors[1]);
                bellGrad.addColorStop(1, colors[2]);
                ctx.fillStyle = bellGrad;
                ctx.fill();

                // Inner bell details (radial patterns)
                ctx.globalAlpha = 0.4;
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(0, currentSize * 0.3);
                    const endX = Math.cos(angle) * currentSize * 0.6;
                    const endY = currentSize * 0.3 + Math.sin(angle) * currentSize * 0.5;
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = colors[0];
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;

                // Oral arms (thick feeding tentacles)
                ctx.shadowBlur = 15;
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2 + this.pulsePhase * 0.1;
                    const baseX = Math.cos(angle) * currentSize * 0.3;
                    const baseY = currentSize * 0.9 + Math.sin(angle) * currentSize * 0.1;

                    ctx.beginPath();
                    ctx.moveTo(baseX, baseY);

                    const armLength = currentSize * 0.8;
                    const segments = 8;
                    for (let j = 1; j <= segments; j++) {
                        const t = j / segments;
                        const wave = Math.sin(this.pulsePhase + j * 0.5) * currentSize * 0.15;
                        const x = baseX + wave;
                        const y = baseY + armLength * t;
                        ctx.lineTo(x, y);
                    }

                    ctx.strokeStyle = colors[1];
                    ctx.lineWidth = 4 * pulse;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                }

                // Long trailing tentacles
                ctx.shadowBlur = 10;
                this.tentacles.forEach((t, idx) => {
                    ctx.save();
                    ctx.rotate(t.offset);

                    ctx.beginPath();
                    ctx.moveTo(0, currentSize * 0.9);

                    const segments = 15;
                    for (let i = 1; i <= segments; i++) {
                        const segT = i / segments;
                        const waveX = Math.sin(t.wave + i * 0.3 + this.pulsePhase) * (3 + Math.sin(this.pulsePhase) * 2);
                        const y = currentSize * 0.9 + (segT * t.length);
                        ctx.lineTo(waveX, y);
                    }

                    // Gradient tentacle
                    const tentGrad = ctx.createLinearGradient(0, currentSize * 0.9, 0, currentSize * 0.9 + t.length);
                    tentGrad.addColorStop(0, colors[1]);
                    tentGrad.addColorStop(1, 'rgba(150, 100, 255, 0)');
                    ctx.strokeStyle = tentGrad;
                    ctx.lineWidth = 2.5 * pulse;
                    ctx.lineCap = 'round';
                    ctx.stroke();

                    // Stinging cells (nematocysts) - small dots along tentacles
                    ctx.globalAlpha = 0.6 * pulse;
                    for (let i = 2; i < segments; i += 2) {
                        const segT = i / segments;
                        const waveX = Math.sin(t.wave + i * 0.3 + this.pulsePhase) * (3 + Math.sin(this.pulsePhase) * 2);
                        const y = currentSize * 0.9 + (segT * t.length);
                        ctx.beginPath();
                        ctx.arc(waveX, y, 1.5, 0, Math.PI * 2);
                        ctx.fillStyle = colors[0];
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;

                    ctx.restore();
                });

                // Bioluminescent spots on bell
                ctx.shadowBlur = 20;
                ctx.globalAlpha = 0.7 * pulse;
                const spots = 12;
                for (let i = 0; i < spots; i++) {
                    const angle = (i / spots) * Math.PI * 2 + this.pulsePhase * 0.2;
                    const radius = currentSize * (0.4 + Math.sin(this.pulsePhase + i) * 0.1);
                    const x = Math.cos(angle) * radius;
                    const y = currentSize * 0.4 + Math.sin(angle) * radius * 0.3;

                    ctx.beginPath();
                    ctx.arc(x, y, 2 + Math.sin(this.pulsePhase + i) * 1, 0, Math.PI * 2);
                    ctx.fillStyle = this.jellyfishVariant === 0 ? 'rgba(200, 150, 255, 0.9)' : 'rgba(150, 220, 255, 0.9)';
                    ctx.fill();
                }
                ctx.globalAlpha = 1;

                ctx.restore();
            }
        }

        // Fish Class with State Machine
        class Fish {
            constructor(x, y, perlin, id) {
                this.x = x;
                this.y = y;
                this.perlin = perlin;
                this.id = id;

                // Assign random fish type
                this.type = FISH_TYPES[Math.floor(Math.random() * FISH_TYPES.length)];

                // Movement
                this.vx = 0;
                this.vy = 0;
                this.angle = Math.random() * Math.PI * 2;
                this.targetAngle = this.angle;
                this.speed = 0;
                this.maxSpeed = 2;

                // Individual characteristics
                this.tension = 0.3 + Math.random() * 0.7; // How easily spooked
                this.laziness = 0.5 + Math.random() * 0.5; // How much it resists moving
                this.speedCoeff = 0.8 + Math.random() * 0.4;

                // State machine
                this.state = 'resting';
                this.stateTime = 0;
                this.restDuration = 2 + Math.random() * 3;

                // Visual
                this.tailPhase = Math.random() * Math.PI * 2;
                this.pupilSize = 1;
                this.glowIntensity = 0.3;
                this.bodyLength = (30 + Math.random() * 20) * this.type.sizeMultiplier;
                this.bodyHeight = this.bodyLength * 0.6;

                // Catch state
                this.isCaught = false;
                this.catchTime = 0;

                // Noise offset
                this.noiseOffsetX = Math.random() * 1000;
                this.noiseOffsetY = Math.random() * 1000;
            }

            update(allFish, handPos, handSpeed, settings, canvas) {
                if (this.isCaught) {
                    this.catchTime += 0.016;
                    if (this.catchTime > 2) {
                        // Respawn
                        this.respawn(canvas);
                    }
                    return;
                }

                this.stateTime += 0.016;

                // Calculate threat level
                let threatLevel = 0;
                if (handPos) {
                    const dx = this.x - handPos.x;
                    const dy = this.y - handPos.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // Speed multiplier
                    const speedMultiplier = Math.min(handSpeed / settings.slowSpeedThreshold, 1);
                    const threatMultiplier = 0.05 + (speedMultiplier * 0.95);

                    if (distance < settings.alertRadius) {
                        threatLevel = (1 - distance / settings.alertRadius) * threatMultiplier * settings.sensitivity * this.tension;
                    }
                }

                // State transitions
                this.updateState(threatLevel, handPos, settings);

                // Behavior based on state
                this.behaviorByState(handPos, settings);

                // Apply separation force
                this.applySeparation(allFish);

                // Boundary forces
                this.applyBoundaryForces(canvas);

                // Turn then move (no sideways sliding)
                this.smoothTurn();

                // Apply velocity
                this.vx = Math.cos(this.angle) * this.speed * this.speedCoeff;
                this.vy = Math.sin(this.angle) * this.speed * this.speedCoeff;

                this.x += this.vx;
                this.y += this.vy;

                // Update visuals
                this.updateVisuals();
            }

            updateState(threatLevel, handPos, settings) {
                switch (this.state) {
                    case 'resting':
                        if (threatLevel > 0.3) {
                            this.state = 'fleeing';
                        } else if (this.stateTime > this.restDuration) {
                            this.state = 'cruising';
                            this.stateTime = 0;
                        }
                        break;

                    case 'cruising':
                        if (threatLevel > 0.3) {
                            this.state = 'fleeing';
                        } else if (threatLevel > 0.1) {
                            this.state = 'alert';
                        } else if (this.stateTime > 3 + Math.random() * 2) {
                            this.state = 'resting';
                            this.stateTime = 0;
                            this.restDuration = 2 + Math.random() * 3;
                        }
                        break;

                    case 'alert':
                        if (threatLevel > 0.4) {
                            this.state = 'fleeing';
                        } else if (threatLevel < 0.05) {
                            this.state = 'cruising';
                        }
                        break;

                    case 'fleeing':
                        if (threatLevel < 0.1) {
                            this.state = 'alert';
                            this.stateTime = 0;
                        }
                        break;
                }
            }

            behaviorByState(handPos, settings) {
                switch (this.state) {
                    case 'resting':
                        this.maxSpeed = 0.5 / this.laziness;
                        this.wander();
                        this.pupilSize = 0.8;
                        this.glowIntensity = 0.3;
                        break;

                    case 'cruising':
                        this.maxSpeed = 1.5 / this.laziness;
                        this.wander();
                        this.pupilSize = 1;
                        this.glowIntensity = 0.4;
                        break;

                    case 'alert':
                        this.maxSpeed = 2 / this.laziness;
                        if (handPos) {
                            this.lookAt(handPos);
                        }
                        this.pupilSize = 0.6;
                        this.glowIntensity = 0.5;
                        break;

                    case 'fleeing':
                        this.maxSpeed = (3 + settings.escapeSpeed) / this.laziness;
                        if (handPos) {
                            this.fleeFrom(handPos);
                        }
                        this.pupilSize = 0.3; // Contracted pupils
                        this.glowIntensity = 0.7; // Fear response
                        break;
                }

                // Accelerate/decelerate
                const accel = this.state === 'fleeing' ? 0.3 : 0.1;
                const decel = 0.05;

                if (this.speed < this.maxSpeed) {
                    this.speed += accel;
                } else {
                    this.speed -= decel;
                }

                this.speed = Math.max(0, Math.min(this.speed, this.maxSpeed));
            }

            wander() {
                // Use Perlin noise for natural movement
                const noiseX = this.perlin.noise(this.noiseOffsetX, 0) * Math.PI * 2;
                const noiseY = this.perlin.noise(0, this.noiseOffsetY) * Math.PI * 2;

                this.targetAngle = Math.atan2(noiseY, noiseX);

                this.noiseOffsetX += 0.005;
                this.noiseOffsetY += 0.005;
            }

            lookAt(target) {
                const dx = target.x - this.x;
                const dy = target.y - this.y;
                this.targetAngle = Math.atan2(dy, dx);
            }

            fleeFrom(threat) {
                const dx = this.x - threat.x;
                const dy = this.y - threat.y;
                this.targetAngle = Math.atan2(dy, dx);
            }

            smoothTurn() {
                // Normalize angle difference
                let angleDiff = this.targetAngle - this.angle;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                // Turn rate based on state
                const turnRate = this.state === 'fleeing' ? 0.15 : 0.05;
                this.angle += angleDiff * turnRate;
            }

            applySeparation(allFish) {
                const separationDist = 60;
                let separationX = 0;
                let separationY = 0;

                allFish.forEach(other => {
                    if (other !== this && !other.isCaught) {
                        const dx = this.x - other.x;
                        const dy = this.y - other.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < separationDist && dist > 0) {
                            const force = (separationDist - dist) / separationDist;
                            separationX += (dx / dist) * force;
                            separationY += (dy / dist) * force;
                        }
                    }
                });

                if (separationX !== 0 || separationY !== 0) {
                    const separationAngle = Math.atan2(separationY, separationX);
                    this.targetAngle = separationAngle;
                }
            }

            applyBoundaryForces(canvas) {
                const margin = 100;
                const turnForce = 0.1;

                if (this.x < margin) {
                    this.targetAngle = 0; // Turn right
                } else if (this.x > canvas.width - margin) {
                    this.targetAngle = Math.PI; // Turn left
                }

                if (this.y < margin) {
                    this.targetAngle = Math.PI / 2; // Turn down
                } else if (this.y > canvas.height - margin) {
                    this.targetAngle = -Math.PI / 2; // Turn up
                }

                // Hard boundaries
                this.x = Math.max(0, Math.min(this.x, canvas.width));
                this.y = Math.max(0, Math.min(this.y, canvas.height));
            }

            updateVisuals() {
                // Tail animation based on speed
                const tailSpeed = 0.1 + (this.speed / this.maxSpeed) * 0.3;
                this.tailPhase += tailSpeed;
            }

            catch() {
                this.isCaught = true;
                this.catchTime = 0;
            }

            respawn(canvas) {
                this.isCaught = false;
                this.catchTime = 0;

                // Respawn at random edge
                const edge = Math.floor(Math.random() * 4);
                switch (edge) {
                    case 0: // Top
                        this.x = Math.random() * canvas.width;
                        this.y = -50;
                        break;
                    case 1: // Right
                        this.x = canvas.width + 50;
                        this.y = Math.random() * canvas.height;
                        break;
                    case 2: // Bottom
                        this.x = Math.random() * canvas.width;
                        this.y = canvas.height + 50;
                        break;
                    case 3: // Left
                        this.x = -50;
                        this.y = Math.random() * canvas.height;
                        break;
                }

                this.state = 'cruising';
                this.speed = this.maxSpeed * 0.5;
            }

            draw(ctx) {
                if (this.isCaught) return;

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Glow effect
                const glowColor = this.type.glowColor;
                ctx.shadowColor = `rgba(${glowColor[0]}, ${glowColor[1]}, ${glowColor[2]}, ${this.glowIntensity})`;
                ctx.shadowBlur = 20;

                const bodyL = this.bodyLength;
                const bodyH = this.bodyHeight;
                const tailSwing = Math.sin(this.tailPhase) * 0.25;

                // Main body with realistic fish shape
                ctx.beginPath();
                ctx.moveTo(-bodyL * 0.4, 0);
                // Top curve (dorsal side)
                ctx.bezierCurveTo(
                    -bodyL * 0.2, -bodyH * 0.5,
                    bodyL * 0.1, -bodyH * 0.5,
                    bodyL * 0.4, -bodyH * 0.2
                );
                // Head curve
                ctx.quadraticCurveTo(bodyL * 0.5, 0, bodyL * 0.4, bodyH * 0.2);
                // Bottom curve (ventral side)
                ctx.bezierCurveTo(
                    bodyL * 0.1, bodyH * 0.5,
                    -bodyL * 0.2, bodyH * 0.5,
                    -bodyL * 0.4, 0
                );

                // Body gradient
                const bodyGrad = ctx.createLinearGradient(-bodyL * 0.4, -bodyH * 0.3, bodyL * 0.4, bodyH * 0.3);
                bodyGrad.addColorStop(0, this.type.colors[2]);
                bodyGrad.addColorStop(0.4, this.type.colors[1]);
                bodyGrad.addColorStop(1, this.type.colors[0]);
                ctx.fillStyle = bodyGrad;
                ctx.fill();

                // Body outline
                ctx.strokeStyle = this.type.colors[2];
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.5;
                ctx.stroke();
                ctx.globalAlpha = 1;

                // Scales pattern
                ctx.globalAlpha = 0.15;
                for (let sx = -bodyL * 0.3; sx < bodyL * 0.4; sx += 8) {
                    for (let sy = -bodyH * 0.3; sy < bodyH * 0.3; sy += 8) {
                        ctx.beginPath();
                        ctx.arc(sx, sy, 3, 0, Math.PI * 2);
                        ctx.strokeStyle = this.type.colors[2];
                        ctx.lineWidth = 0.5;
                        ctx.stroke();
                    }
                }
                ctx.globalAlpha = 1;

                // Dorsal fin (top)
                ctx.beginPath();
                ctx.moveTo(0, -bodyH * 0.5);
                ctx.bezierCurveTo(
                    -bodyL * 0.1, -bodyH * 0.7,
                    -bodyL * 0.15, -bodyH * 0.7,
                    -bodyL * 0.2, -bodyH * 0.5
                );
                ctx.closePath();
                const dorsalGrad = ctx.createLinearGradient(0, -bodyH * 0.5, 0, -bodyH * 0.7);
                dorsalGrad.addColorStop(0, this.type.colors[1]);
                dorsalGrad.addColorStop(1, this.type.colors[0]);
                ctx.fillStyle = dorsalGrad;
                ctx.fill();
                ctx.strokeStyle = this.type.colors[2];
                ctx.lineWidth = 1;
                ctx.stroke();

                // Pectoral fin (side)
                ctx.beginPath();
                ctx.moveTo(bodyL * 0.1, bodyH * 0.1);
                ctx.quadraticCurveTo(
                    bodyL * 0.15, bodyH * 0.35,
                    bodyL * 0.05, bodyH * 0.4
                );
                ctx.quadraticCurveTo(
                    bodyL * 0.05, bodyH * 0.2,
                    bodyL * 0.1, bodyH * 0.1
                );
                ctx.fillStyle = this.type.colors[1];
                ctx.globalAlpha = 0.7;
                ctx.fill();
                ctx.globalAlpha = 1;

                // Anal fin (bottom rear)
                ctx.beginPath();
                ctx.moveTo(-bodyL * 0.15, bodyH * 0.5);
                ctx.quadraticCurveTo(
                    -bodyL * 0.2, bodyH * 0.65,
                    -bodyL * 0.25, bodyH * 0.5
                );
                ctx.fillStyle = this.type.colors[1];
                ctx.fill();

                // Caudal fin (tail) - animated
                ctx.save();
                ctx.translate(-bodyL * 0.4, 0);
                ctx.rotate(tailSwing * 0.5);
                ctx.beginPath();
                // Upper lobe
                ctx.moveTo(0, 0);
                ctx.quadraticCurveTo(-bodyL * 0.15, -bodyH * 0.4, -bodyL * 0.25, -bodyH * 0.5);
                // Lower lobe
                ctx.lineTo(-bodyL * 0.25, bodyH * 0.5);
                ctx.quadraticCurveTo(-bodyL * 0.15, bodyH * 0.4, 0, 0);
                ctx.closePath();
                const tailGrad = ctx.createLinearGradient(0, -bodyH * 0.5, 0, bodyH * 0.5);
                tailGrad.addColorStop(0, this.type.colors[0]);
                tailGrad.addColorStop(0.5, this.type.colors[1]);
                tailGrad.addColorStop(1, this.type.colors[0]);
                ctx.fillStyle = tailGrad;
                ctx.fill();
                ctx.strokeStyle = this.type.colors[2];
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.restore();

                // Eye
                const eyeX = bodyL * 0.35;
                const eyeY = -bodyH * 0.15;

                // Eye white (smaller)
                ctx.beginPath();
                ctx.ellipse(eyeX, eyeY, 3.5, 3, 0, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.shadowBlur = 0;
                ctx.fill();

                // Iris (smaller)
                ctx.beginPath();
                ctx.arc(eyeX, eyeY, 2.5, 0, Math.PI * 2);
                const irisGrad = ctx.createRadialGradient(eyeX, eyeY, 0, eyeX, eyeY, 2.5);
                irisGrad.addColorStop(0, '#ffcc00');
                irisGrad.addColorStop(1, '#cc6600');
                ctx.fillStyle = irisGrad;
                ctx.fill();

                // Pupil (smaller)
                ctx.beginPath();
                ctx.arc(eyeX, eyeY, 1.5 * this.pupilSize, 0, Math.PI * 2);
                ctx.fillStyle = 'black';
                ctx.fill();

                // Eye highlight (smaller)
                ctx.beginPath();
                ctx.arc(eyeX + 1, eyeY - 1, 1, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fill();

                // Mouth detail
                ctx.beginPath();
                ctx.moveTo(bodyL * 0.48, bodyH * 0.05);
                ctx.quadraticCurveTo(bodyL * 0.5, bodyH * 0.1, bodyL * 0.47, bodyH * 0.15);
                ctx.strokeStyle = this.type.colors[2];
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.6;
                ctx.stroke();
                ctx.globalAlpha = 1;

                ctx.restore();
            }
        }

        // Start game
        window.addEventListener('load', () => {
            new Game();
        });
    </script>
</body>
</html>
